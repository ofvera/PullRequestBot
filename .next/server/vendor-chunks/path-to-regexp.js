"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/path-to-regexp";
exports.ids = ["vendor-chunks/path-to-regexp"];
exports.modules = {

/***/ "(rsc)/./node_modules/path-to-regexp/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/path-to-regexp/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TokenData = void 0;\nexports.parse = parse;\nexports.compile = compile;\nexports.match = match;\nexports.pathToRegexp = pathToRegexp;\nexports.stringify = stringify;\nconst DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value)=>value;\nconst ID_START = /^[$_\\p{ID_Start}]$/u;\nconst ID_CONTINUE = /^[$\\u200c\\u200d\\p{ID_Continue}]$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\nconst SIMPLE_TOKENS = {\n    // Groups.\n    \"{\": \"{\",\n    \"}\": \"}\",\n    // Reserved.\n    \"(\": \"(\",\n    \")\": \")\",\n    \"[\": \"[\",\n    \"]\": \"]\",\n    \"+\": \"+\",\n    \"?\": \"?\",\n    \"!\": \"!\"\n};\n/**\n * Escape text for stringify to path.\n */ function escapeText(str) {\n    return str.replace(/[{}()\\[\\]+?!:*]/g, \"\\\\$&\");\n}\n/**\n * Escape a regular expression string.\n */ function escape(str) {\n    return str.replace(/[.+*?^${}()[\\]|/\\\\]/g, \"\\\\$&\");\n}\n/**\n * Tokenize input string.\n */ function* lexer(str) {\n    const chars = [\n        ...str\n    ];\n    let i = 0;\n    function name() {\n        let value = \"\";\n        if (ID_START.test(chars[++i])) {\n            value += chars[i];\n            while(ID_CONTINUE.test(chars[++i])){\n                value += chars[i];\n            }\n        } else if (chars[i] === '\"') {\n            let pos = i;\n            while(i < chars.length){\n                if (chars[++i] === '\"') {\n                    i++;\n                    pos = 0;\n                    break;\n                }\n                if (chars[i] === \"\\\\\") {\n                    value += chars[++i];\n                } else {\n                    value += chars[i];\n                }\n            }\n            if (pos) {\n                throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);\n            }\n        }\n        if (!value) {\n            throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);\n        }\n        return value;\n    }\n    while(i < chars.length){\n        const value = chars[i];\n        const type = SIMPLE_TOKENS[value];\n        if (type) {\n            yield {\n                type,\n                index: i++,\n                value\n            };\n        } else if (value === \"\\\\\") {\n            yield {\n                type: \"ESCAPED\",\n                index: i++,\n                value: chars[i++]\n            };\n        } else if (value === \":\") {\n            const value = name();\n            yield {\n                type: \"PARAM\",\n                index: i,\n                value\n            };\n        } else if (value === \"*\") {\n            const value = name();\n            yield {\n                type: \"WILDCARD\",\n                index: i,\n                value\n            };\n        } else {\n            yield {\n                type: \"CHAR\",\n                index: i,\n                value: chars[i++]\n            };\n        }\n    }\n    return {\n        type: \"END\",\n        index: i,\n        value: \"\"\n    };\n}\nclass Iter {\n    constructor(tokens){\n        this.tokens = tokens;\n    }\n    peek() {\n        if (!this._peek) {\n            const next = this.tokens.next();\n            this._peek = next.value;\n        }\n        return this._peek;\n    }\n    tryConsume(type) {\n        const token = this.peek();\n        if (token.type !== type) return;\n        this._peek = undefined; // Reset after consumed.\n        return token.value;\n    }\n    consume(type) {\n        const value = this.tryConsume(type);\n        if (value !== undefined) return value;\n        const { type: nextType, index } = this.peek();\n        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`);\n    }\n    text() {\n        let result = \"\";\n        let value;\n        while(value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\")){\n            result += value;\n        }\n        return result;\n    }\n}\n/**\n * Tokenized path instance.\n */ class TokenData {\n    constructor(tokens){\n        this.tokens = tokens;\n    }\n}\nexports.TokenData = TokenData;\n/**\n * Parse a string for the raw tokens.\n */ function parse(str, options = {}) {\n    const { encodePath = NOOP_VALUE } = options;\n    const it = new Iter(lexer(str));\n    function consume(endType) {\n        const tokens = [];\n        while(true){\n            const path = it.text();\n            if (path) tokens.push({\n                type: \"text\",\n                value: encodePath(path)\n            });\n            const param = it.tryConsume(\"PARAM\");\n            if (param) {\n                tokens.push({\n                    type: \"param\",\n                    name: param\n                });\n                continue;\n            }\n            const wildcard = it.tryConsume(\"WILDCARD\");\n            if (wildcard) {\n                tokens.push({\n                    type: \"wildcard\",\n                    name: wildcard\n                });\n                continue;\n            }\n            const open = it.tryConsume(\"{\");\n            if (open) {\n                tokens.push({\n                    type: \"group\",\n                    tokens: consume(\"}\")\n                });\n                continue;\n            }\n            it.consume(endType);\n            return tokens;\n        }\n    }\n    const tokens = consume(\"END\");\n    return new TokenData(tokens);\n}\n/**\n * Compile a string to a template function for the path.\n */ function compile(path, options = {}) {\n    const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;\n    const data = path instanceof TokenData ? path : parse(path, options);\n    const fn = tokensToFunction(data.tokens, delimiter, encode);\n    return function path(data = {}) {\n        const [path, ...missing] = fn(data);\n        if (missing.length) {\n            throw new TypeError(`Missing parameters: ${missing.join(\", \")}`);\n        }\n        return path;\n    };\n}\nfunction tokensToFunction(tokens, delimiter, encode) {\n    const encoders = tokens.map((token)=>tokenToFunction(token, delimiter, encode));\n    return (data)=>{\n        const result = [\n            \"\"\n        ];\n        for (const encoder of encoders){\n            const [value, ...extras] = encoder(data);\n            result[0] += value;\n            result.push(...extras);\n        }\n        return result;\n    };\n}\n/**\n * Convert a single token into a path building function.\n */ function tokenToFunction(token, delimiter, encode) {\n    if (token.type === \"text\") return ()=>[\n            token.value\n        ];\n    if (token.type === \"group\") {\n        const fn = tokensToFunction(token.tokens, delimiter, encode);\n        return (data)=>{\n            const [value, ...missing] = fn(data);\n            if (!missing.length) return [\n                value\n            ];\n            return [\n                \"\"\n            ];\n        };\n    }\n    const encodeValue = encode || NOOP_VALUE;\n    if (token.type === \"wildcard\" && encode !== false) {\n        return (data)=>{\n            const value = data[token.name];\n            if (value == null) return [\n                \"\",\n                token.name\n            ];\n            if (!Array.isArray(value) || value.length === 0) {\n                throw new TypeError(`Expected \"${token.name}\" to be a non-empty array`);\n            }\n            return [\n                value.map((value, index)=>{\n                    if (typeof value !== \"string\") {\n                        throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n                    }\n                    return encodeValue(value);\n                }).join(delimiter)\n            ];\n        };\n    }\n    return (data)=>{\n        const value = data[token.name];\n        if (value == null) return [\n            \"\",\n            token.name\n        ];\n        if (typeof value !== \"string\") {\n            throw new TypeError(`Expected \"${token.name}\" to be a string`);\n        }\n        return [\n            encodeValue(value)\n        ];\n    };\n}\n/**\n * Transform a path into a match function.\n */ function match(path, options = {}) {\n    const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;\n    const { regexp, keys } = pathToRegexp(path, options);\n    const decoders = keys.map((key)=>{\n        if (decode === false) return NOOP_VALUE;\n        if (key.type === \"param\") return decode;\n        return (value)=>value.split(delimiter).map(decode);\n    });\n    return function match(input) {\n        const m = regexp.exec(input);\n        if (!m) return false;\n        const path = m[0];\n        const params = Object.create(null);\n        for(let i = 1; i < m.length; i++){\n            if (m[i] === undefined) continue;\n            const key = keys[i - 1];\n            const decoder = decoders[i - 1];\n            params[key.name] = decoder(m[i]);\n        }\n        return {\n            path,\n            params\n        };\n    };\n}\nfunction pathToRegexp(path, options = {}) {\n    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;\n    const keys = [];\n    const sources = [];\n    const flags = sensitive ? \"\" : \"i\";\n    const paths = Array.isArray(path) ? path : [\n        path\n    ];\n    const items = paths.map((path)=>path instanceof TokenData ? path : parse(path, options));\n    for (const { tokens } of items){\n        for (const seq of flatten(tokens, 0, [])){\n            const regexp = sequenceToRegExp(seq, delimiter, keys);\n            sources.push(regexp);\n        }\n    }\n    let pattern = `^(?:${sources.join(\"|\")})`;\n    if (trailing) pattern += `(?:${escape(delimiter)}$)?`;\n    pattern += end ? \"$\" : `(?=${escape(delimiter)}|$)`;\n    const regexp = new RegExp(pattern, flags);\n    return {\n        regexp,\n        keys\n    };\n}\n/**\n * Generate a flat list of sequence tokens from the given tokens.\n */ function* flatten(tokens, index, init) {\n    if (index === tokens.length) {\n        return yield init;\n    }\n    const token = tokens[index];\n    if (token.type === \"group\") {\n        const fork = init.slice();\n        for (const seq of flatten(token.tokens, 0, fork)){\n            yield* flatten(tokens, index + 1, seq);\n        }\n    } else {\n        init.push(token);\n    }\n    yield* flatten(tokens, index + 1, init);\n}\n/**\n * Transform a flat sequence of tokens into a regular expression.\n */ function sequenceToRegExp(tokens, delimiter, keys) {\n    let result = \"\";\n    let backtrack = \"\";\n    let isSafeSegmentParam = true;\n    for(let i = 0; i < tokens.length; i++){\n        const token = tokens[i];\n        if (token.type === \"text\") {\n            result += escape(token.value);\n            backtrack += token.value;\n            isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));\n            continue;\n        }\n        if (token.type === \"param\" || token.type === \"wildcard\") {\n            if (!isSafeSegmentParam && !backtrack) {\n                throw new TypeError(`Missing text after \"${token.name}\": ${DEBUG_URL}`);\n            }\n            if (token.type === \"param\") {\n                result += `(${negate(delimiter, isSafeSegmentParam ? \"\" : backtrack)}+)`;\n            } else {\n                result += `([\\\\s\\\\S]+)`;\n            }\n            keys.push(token);\n            backtrack = \"\";\n            isSafeSegmentParam = false;\n            continue;\n        }\n    }\n    return result;\n}\nfunction negate(delimiter, backtrack) {\n    if (backtrack.length < 2) {\n        if (delimiter.length < 2) return `[^${escape(delimiter + backtrack)}]`;\n        return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;\n    }\n    if (delimiter.length < 2) {\n        return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;\n    }\n    return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\\\s\\\\S])`;\n}\n/**\n * Stringify token data into a path string.\n */ function stringify(data) {\n    return data.tokens.map(function stringifyToken(token, index, tokens) {\n        if (token.type === \"text\") return escapeText(token.value);\n        if (token.type === \"group\") {\n            return `{${token.tokens.map(stringifyToken).join(\"\")}}`;\n        }\n        const isSafe = isNameSafe(token.name) && isNextNameSafe(tokens[index + 1]);\n        const key = isSafe ? token.name : JSON.stringify(token.name);\n        if (token.type === \"param\") return `:${key}`;\n        if (token.type === \"wildcard\") return `*${key}`;\n        throw new TypeError(`Unexpected token: ${token}`);\n    }).join(\"\");\n}\nfunction isNameSafe(name) {\n    const [first, ...rest] = name;\n    if (!ID_START.test(first)) return false;\n    return rest.every((char)=>ID_CONTINUE.test(char));\n}\nfunction isNextNameSafe(token) {\n    if ((token === null || token === void 0 ? void 0 : token.type) !== \"text\") return true;\n    return !ID_CONTINUE.test(token.value[0]);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QkEsYUFBYSxHQUFHRztBQUNoQkgsZUFBZSxHQUFHSTtBQUNsQkosYUFBYSxHQUFHSztBQUNoQkwsb0JBQW9CLEdBQUdNO0FBQ3ZCTixpQkFBaUIsR0FBR087QUFDcEIsTUFBTUMsb0JBQW9CO0FBQzFCLE1BQU1DLGFBQWEsQ0FBQ1IsUUFBVUE7QUFDOUIsTUFBTVMsV0FBVztBQUNqQixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsZ0JBQWdCO0lBQ2xCLFVBQVU7SUFDVixLQUFLO0lBQ0wsS0FBSztJQUNMLFlBQVk7SUFDWixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLFdBQVdDLEdBQUc7SUFDbkIsT0FBT0EsSUFBSUMsT0FBTyxDQUFDLG9CQUFvQjtBQUMzQztBQUNBOztDQUVDLEdBQ0QsU0FBU0MsT0FBT0YsR0FBRztJQUNmLE9BQU9BLElBQUlDLE9BQU8sQ0FBQyx3QkFBd0I7QUFDL0M7QUFDQTs7Q0FFQyxHQUNELFVBQVVFLE1BQU1ILEdBQUc7SUFDZixNQUFNSSxRQUFRO1dBQUlKO0tBQUk7SUFDdEIsSUFBSUssSUFBSTtJQUNSLFNBQVNDO1FBQ0wsSUFBSXBCLFFBQVE7UUFDWixJQUFJUyxTQUFTWSxJQUFJLENBQUNILEtBQUssQ0FBQyxFQUFFQyxFQUFFLEdBQUc7WUFDM0JuQixTQUFTa0IsS0FBSyxDQUFDQyxFQUFFO1lBQ2pCLE1BQU9ULFlBQVlXLElBQUksQ0FBQ0gsS0FBSyxDQUFDLEVBQUVDLEVBQUUsRUFBRztnQkFDakNuQixTQUFTa0IsS0FBSyxDQUFDQyxF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QyxNQUFNVCxJQUFJLEtBQUssU0FBUztZQUN4QixPQUFPLENBQUMsQ0FBQyxFQUFFUyxNQUFNTCxNQUFNLENBQUM2QixHQUFHLENBQUN1QyxnQkFBZ0J6QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0Q7UUFDQSxNQUFNMEMsU0FBU0MsV0FBV2pFLE1BQU1kLElBQUksS0FBS2dGLGVBQWV2RSxNQUFNLENBQUNILFFBQVEsRUFBRTtRQUN6RSxNQUFNNEMsTUFBTTRCLFNBQVNoRSxNQUFNZCxJQUFJLEdBQUdpRixLQUFLL0YsU0FBUyxDQUFDNEIsTUFBTWQsSUFBSTtRQUMzRCxJQUFJYyxNQUFNVCxJQUFJLEtBQUssU0FDZixPQUFPLENBQUMsQ0FBQyxFQUFFNkMsSUFBSSxDQUFDO1FBQ3BCLElBQUlwQyxNQUFNVCxJQUFJLEtBQUssWUFDZixPQUFPLENBQUMsQ0FBQyxFQUFFNkMsSUFBSSxDQUFDO1FBQ3BCLE1BQU0sSUFBSTlDLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRVUsTUFBTSxDQUFDO0lBQ3BELEdBQ0tzQixJQUFJLENBQUM7QUFDZDtBQUNBLFNBQVMyQyxXQUFXL0UsSUFBSTtJQUNwQixNQUFNLENBQUNrRixPQUFPLEdBQUdDLEtBQUssR0FBR25GO0lBQ3pCLElBQUksQ0FBQ1gsU0FBU1ksSUFBSSxDQUFDaUYsUUFDZixPQUFPO0lBQ1gsT0FBT0MsS0FBS0MsS0FBSyxDQUFDLENBQUNDLE9BQVMvRixZQUFZVyxJQUFJLENBQUNvRjtBQUNqRDtBQUNBLFNBQVNMLGVBQWVsRSxLQUFLO0lBQ3pCLElBQUksQ0FBQ0EsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1ULElBQUksTUFBTSxRQUMvRCxPQUFPO0lBQ1gsT0FBTyxDQUFDZixZQUFZVyxJQUFJLENBQUNhLE1BQU1sQyxLQUFLLENBQUMsRUFBRTtBQUMzQyxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3B1bGxyZXF1ZXN0Ym90Ly4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2Rpc3QvaW5kZXguanM/YWE5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5EYXRhID0gdm9pZCAwO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbmV4cG9ydHMucGF0aFRvUmVnZXhwID0gcGF0aFRvUmVnZXhwO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5jb25zdCBERUZBVUxUX0RFTElNSVRFUiA9IFwiL1wiO1xuY29uc3QgTk9PUF9WQUxVRSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBJRF9TVEFSVCA9IC9eWyRfXFxwe0lEX1N0YXJ0fV0kL3U7XG5jb25zdCBJRF9DT05USU5VRSA9IC9eWyRcXHUyMDBjXFx1MjAwZFxccHtJRF9Db250aW51ZX1dJC91O1xuY29uc3QgREVCVUdfVVJMID0gXCJodHRwczovL2dpdC5uZXcvcGF0aFRvUmVnZXhwRXJyb3JcIjtcbmNvbnN0IFNJTVBMRV9UT0tFTlMgPSB7XG4gICAgLy8gR3JvdXBzLlxuICAgIFwie1wiOiBcIntcIixcbiAgICBcIn1cIjogXCJ9XCIsXG4gICAgLy8gUmVzZXJ2ZWQuXG4gICAgXCIoXCI6IFwiKFwiLFxuICAgIFwiKVwiOiBcIilcIixcbiAgICBcIltcIjogXCJbXCIsXG4gICAgXCJdXCI6IFwiXVwiLFxuICAgIFwiK1wiOiBcIitcIixcbiAgICBcIj9cIjogXCI/XCIsXG4gICAgXCIhXCI6IFwiIVwiLFxufTtcbi8qKlxuICogRXNjYXBlIHRleHQgZm9yIHN0cmluZ2lmeSB0byBwYXRoLlxuICovXG5mdW5jdGlvbiBlc2NhcGVUZXh0KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW3t9KClcXFtcXF0rPyE6Kl0vZywgXCJcXFxcJCZcIik7XG59XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKyo/XiR7fSgpW1xcXXwvXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24qIGxleGVyKHN0cikge1xuICAgIGNvbnN0IGNoYXJzID0gWy4uLnN0cl07XG4gICAgbGV0IGkgPSAwO1xuICAgIGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGlmIChJRF9TVEFSVC50ZXN0KGNoYXJzWysraV0pKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjaGFyc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChJRF9DT05USU5VRS50ZXN0KGNoYXJzWysraV0pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gY2hhcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcnNbaV0gPT09ICdcIicpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbKytpXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGNoYXJzWysraV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaGFyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW50ZXJtaW5hdGVkIHF1b3RlIGF0ICR7cG9zfTogJHtERUJVR19VUkx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCAke2l9OiAke0RFQlVHX1VSTH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHdoaWxlIChpIDwgY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY2hhcnNbaV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSBTSU1QTEVfVE9LRU5TW3ZhbHVlXTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZSwgaW5kZXg6IGkrKywgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJFU0NBUEVEXCIsIGluZGV4OiBpKyssIHZhbHVlOiBjaGFyc1tpKytdIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5hbWUoKTtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJQQVJBTVwiLCBpbmRleDogaSwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmFtZSgpO1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBcIldJTERDQVJEXCIsIGluZGV4OiBpLCB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBjaGFyc1tpKytdIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH07XG59XG5jbGFzcyBJdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGVlaykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMudG9rZW5zLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlZWsgPSBuZXh0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wZWVrO1xuICAgIH1cbiAgICB0cnlDb25zdW1lKHR5cGUpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3BlZWsgPSB1bmRlZmluZWQ7IC8vIFJlc2V0IGFmdGVyIGNvbnN1bWVkLlxuICAgICAgICByZXR1cm4gdG9rZW4udmFsdWU7XG4gICAgfVxuICAgIGNvbnN1bWUodHlwZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudHJ5Q29uc3VtZSh0eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNvbnN0IHsgdHlwZTogbmV4dFR5cGUsIGluZGV4IH0gPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5leHBlY3RlZCAke25leHRUeXBlfSBhdCAke2luZGV4fSwgZXhwZWN0ZWQgJHt0eXBlfTogJHtERUJVR19VUkx9YCk7XG4gICAgfVxuICAgIHRleHQoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIHdoaWxlICgodmFsdWUgPSB0aGlzLnRyeUNvbnN1bWUoXCJDSEFSXCIpIHx8IHRoaXMudHJ5Q29uc3VtZShcIkVTQ0FQRURcIikpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIFRva2VuaXplZCBwYXRoIGluc3RhbmNlLlxuICovXG5jbGFzcyBUb2tlbkRhdGEge1xuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICB9XG59XG5leHBvcnRzLlRva2VuRGF0YSA9IFRva2VuRGF0YTtcbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZW5jb2RlUGF0aCA9IE5PT1BfVkFMVUUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXQgPSBuZXcgSXRlcihsZXhlcihzdHIpKTtcbiAgICBmdW5jdGlvbiBjb25zdW1lKGVuZFR5cGUpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gaXQudGV4dCgpO1xuICAgICAgICAgICAgaWYgKHBhdGgpXG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGVuY29kZVBhdGgocGF0aCkgfSk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGl0LnRyeUNvbnN1bWUoXCJQQVJBTVwiKTtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwYXJhbVwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdpbGRjYXJkID0gaXQudHJ5Q29uc3VtZShcIldJTERDQVJEXCIpO1xuICAgICAgICAgICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIndpbGRjYXJkXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHdpbGRjYXJkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BlbiA9IGl0LnRyeUNvbnN1bWUoXCJ7XCIpO1xuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBjb25zdW1lKFwifVwiKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0LmNvbnN1bWUoZW5kVHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IGNvbnN1bWUoXCJFTkRcIik7XG4gICAgcmV0dXJuIG5ldyBUb2tlbkRhdGEodG9rZW5zKTtcbn1cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudCwgZGVsaW1pdGVyID0gREVGQVVMVF9ERUxJTUlURVIgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZGF0YSA9IHBhdGggaW5zdGFuY2VvZiBUb2tlbkRhdGEgPyBwYXRoIDogcGFyc2UocGF0aCwgb3B0aW9ucyk7XG4gICAgY29uc3QgZm4gPSB0b2tlbnNUb0Z1bmN0aW9uKGRhdGEudG9rZW5zLCBkZWxpbWl0ZXIsIGVuY29kZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGgoZGF0YSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCAuLi5taXNzaW5nXSA9IGZuKGRhdGEpO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1pc3NpbmcgcGFyYW1ldGVyczogJHttaXNzaW5nLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbih0b2tlbnMsIGRlbGltaXRlciwgZW5jb2RlKSB7XG4gICAgY29uc3QgZW5jb2RlcnMgPSB0b2tlbnMubWFwKCh0b2tlbikgPT4gdG9rZW5Ub0Z1bmN0aW9uKHRva2VuLCBkZWxpbWl0ZXIsIGVuY29kZSkpO1xuICAgIHJldHVybiAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXCJcIl07XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2RlciBvZiBlbmNvZGVycykge1xuICAgICAgICAgICAgY29uc3QgW3ZhbHVlLCAuLi5leHRyYXNdID0gZW5jb2RlcihkYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFswXSArPSB2YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmV4dHJhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHRva2VuIGludG8gYSBwYXRoIGJ1aWxkaW5nIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlblRvRnVuY3Rpb24odG9rZW4sIGRlbGltaXRlciwgZW5jb2RlKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFwidGV4dFwiKVxuICAgICAgICByZXR1cm4gKCkgPT4gW3Rva2VuLnZhbHVlXTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgIGNvbnN0IGZuID0gdG9rZW5zVG9GdW5jdGlvbih0b2tlbi50b2tlbnMsIGRlbGltaXRlciwgZW5jb2RlKTtcbiAgICAgICAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIC4uLm1pc3NpbmddID0gZm4oZGF0YSk7XG4gICAgICAgICAgICBpZiAoIW1pc3NpbmcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIFtcIlwiXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlVmFsdWUgPSBlbmNvZGUgfHwgTk9PUF9WQUxVRTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJ3aWxkY2FyZFwiICYmIGVuY29kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiXCIsIHRva2VuLm5hbWVdO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcIiR7dG9rZW4ubmFtZX1cIiB0byBiZSBhIG5vbi1lbXB0eSBhcnJheWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXCIke3Rva2VuLm5hbWV9LyR7aW5kZXh9XCIgdG8gYmUgYSBzdHJpbmdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKGRlbGltaXRlciksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBbXCJcIiwgdG9rZW4ubmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFwiJHt0b2tlbi5uYW1lfVwiIHRvIGJlIGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtlbmNvZGVWYWx1ZSh2YWx1ZSldO1xuICAgIH07XG59XG4vKipcbiAqIFRyYW5zZm9ybSBhIHBhdGggaW50byBhIG1hdGNoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudCwgZGVsaW1pdGVyID0gREVGQVVMVF9ERUxJTUlURVIgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByZWdleHAsIGtleXMgfSA9IHBhdGhUb1JlZ2V4cChwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBkZWNvZGVycyA9IGtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGRlY29kZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gTk9PUF9WQUxVRTtcbiAgICAgICAgaWYgKGtleS50eXBlID09PSBcInBhcmFtXCIpXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlO1xuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB2YWx1ZS5zcGxpdChkZWxpbWl0ZXIpLm1hcChkZWNvZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaChpbnB1dCkge1xuICAgICAgICBjb25zdCBtID0gcmVnZXhwLmV4ZWMoaW5wdXQpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhdGggPSBtWzBdO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtW2ldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2kgLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBkZWNvZGVyc1tpIC0gMV07XG4gICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlcihtW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoLCBwYXJhbXMgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGVsaW1pdGVyID0gREVGQVVMVF9ERUxJTUlURVIsIGVuZCA9IHRydWUsIHNlbnNpdGl2ZSA9IGZhbHNlLCB0cmFpbGluZyA9IHRydWUsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgY29uc3QgZmxhZ3MgPSBzZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG4gICAgY29uc3QgcGF0aHMgPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IFtwYXRoXTtcbiAgICBjb25zdCBpdGVtcyA9IHBhdGhzLm1hcCgocGF0aCkgPT4gcGF0aCBpbnN0YW5jZW9mIFRva2VuRGF0YSA/IHBhdGggOiBwYXJzZShwYXRoLCBvcHRpb25zKSk7XG4gICAgZm9yIChjb25zdCB7IHRva2VucyB9IG9mIGl0ZW1zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2VxIG9mIGZsYXR0ZW4odG9rZW5zLCAwLCBbXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4cCA9IHNlcXVlbmNlVG9SZWdFeHAoc2VxLCBkZWxpbWl0ZXIsIGtleXMpO1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHJlZ2V4cCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBhdHRlcm4gPSBgXig/OiR7c291cmNlcy5qb2luKFwifFwiKX0pYDtcbiAgICBpZiAodHJhaWxpbmcpXG4gICAgICAgIHBhdHRlcm4gKz0gYCg/OiR7ZXNjYXBlKGRlbGltaXRlcil9JCk/YDtcbiAgICBwYXR0ZXJuICs9IGVuZCA/IFwiJFwiIDogYCg/PSR7ZXNjYXBlKGRlbGltaXRlcil9fCQpYDtcbiAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICByZXR1cm4geyByZWdleHAsIGtleXMgfTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBmbGF0IGxpc3Qgb2Ygc2VxdWVuY2UgdG9rZW5zIGZyb20gdGhlIGdpdmVuIHRva2Vucy5cbiAqL1xuZnVuY3Rpb24qIGZsYXR0ZW4odG9rZW5zLCBpbmRleCwgaW5pdCkge1xuICAgIGlmIChpbmRleCA9PT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geWllbGQgaW5pdDtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaW5kZXhdO1xuICAgIGlmICh0b2tlbi50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgY29uc3QgZm9yayA9IGluaXQuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBzZXEgb2YgZmxhdHRlbih0b2tlbi50b2tlbnMsIDAsIGZvcmspKSB7XG4gICAgICAgICAgICB5aWVsZCogZmxhdHRlbih0b2tlbnMsIGluZGV4ICsgMSwgc2VxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5pdC5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgeWllbGQqIGZsYXR0ZW4odG9rZW5zLCBpbmRleCArIDEsIGluaXQpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBmbGF0IHNlcXVlbmNlIG9mIHRva2VucyBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBzZXF1ZW5jZVRvUmVnRXhwKHRva2VucywgZGVsaW1pdGVyLCBrZXlzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgbGV0IGJhY2t0cmFjayA9IFwiXCI7XG4gICAgbGV0IGlzU2FmZVNlZ21lbnRQYXJhbSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZSh0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICBiYWNrdHJhY2sgKz0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICBpc1NhZmVTZWdtZW50UGFyYW0gfHwgKGlzU2FmZVNlZ21lbnRQYXJhbSA9IHRva2VuLnZhbHVlLmluY2x1ZGVzKGRlbGltaXRlcikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwicGFyYW1cIiB8fCB0b2tlbi50eXBlID09PSBcIndpbGRjYXJkXCIpIHtcbiAgICAgICAgICAgIGlmICghaXNTYWZlU2VnbWVudFBhcmFtICYmICFiYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIHRleHQgYWZ0ZXIgXCIke3Rva2VuLm5hbWV9XCI6ICR7REVCVUdfVVJMfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwicGFyYW1cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgKCR7bmVnYXRlKGRlbGltaXRlciwgaXNTYWZlU2VnbWVudFBhcmFtID8gXCJcIiA6IGJhY2t0cmFjayl9KylgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGAoW1xcXFxzXFxcXFNdKylgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIGJhY2t0cmFjayA9IFwiXCI7XG4gICAgICAgICAgICBpc1NhZmVTZWdtZW50UGFyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuZWdhdGUoZGVsaW1pdGVyLCBiYWNrdHJhY2spIHtcbiAgICBpZiAoYmFja3RyYWNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaWYgKGRlbGltaXRlci5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIGBbXiR7ZXNjYXBlKGRlbGltaXRlciArIGJhY2t0cmFjayl9XWA7XG4gICAgICAgIHJldHVybiBgKD86KD8hJHtlc2NhcGUoZGVsaW1pdGVyKX0pW14ke2VzY2FwZShiYWNrdHJhY2spfV0pYDtcbiAgICB9XG4gICAgaWYgKGRlbGltaXRlci5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBgKD86KD8hJHtlc2NhcGUoYmFja3RyYWNrKX0pW14ke2VzY2FwZShkZWxpbWl0ZXIpfV0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGAoPzooPyEke2VzY2FwZShiYWNrdHJhY2spfXwke2VzY2FwZShkZWxpbWl0ZXIpfSlbXFxcXHNcXFxcU10pYDtcbn1cbi8qKlxuICogU3RyaW5naWZ5IHRva2VuIGRhdGEgaW50byBhIHBhdGggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnRva2Vuc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIHN0cmluZ2lmeVRva2VuKHRva2VuLCBpbmRleCwgdG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcInRleHRcIilcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVUZXh0KHRva2VuLnZhbHVlKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB7JHt0b2tlbi50b2tlbnMubWFwKHN0cmluZ2lmeVRva2VuKS5qb2luKFwiXCIpfX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU2FmZSA9IGlzTmFtZVNhZmUodG9rZW4ubmFtZSkgJiYgaXNOZXh0TmFtZVNhZmUodG9rZW5zW2luZGV4ICsgMV0pO1xuICAgICAgICBjb25zdCBrZXkgPSBpc1NhZmUgPyB0b2tlbi5uYW1lIDogSlNPTi5zdHJpbmdpZnkodG9rZW4ubmFtZSk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcInBhcmFtXCIpXG4gICAgICAgICAgICByZXR1cm4gYDoke2tleX1gO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJ3aWxkY2FyZFwiKVxuICAgICAgICAgICAgcmV0dXJuIGAqJHtrZXl9YDtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5leHBlY3RlZCB0b2tlbjogJHt0b2tlbn1gKTtcbiAgICB9KVxuICAgICAgICAuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZVNhZmUobmFtZSkge1xuICAgIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSBuYW1lO1xuICAgIGlmICghSURfU1RBUlQudGVzdChmaXJzdCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVzdC5ldmVyeSgoY2hhcikgPT4gSURfQ09OVElOVUUudGVzdChjaGFyKSk7XG59XG5mdW5jdGlvbiBpc05leHROYW1lU2FmZSh0b2tlbikge1xuICAgIGlmICgodG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2VuLnR5cGUpICE9PSBcInRleHRcIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuICFJRF9DT05USU5VRS50ZXN0KHRva2VuLnZhbHVlWzBdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRva2VuRGF0YSIsInBhcnNlIiwiY29tcGlsZSIsIm1hdGNoIiwicGF0aFRvUmVnZXhwIiwic3RyaW5naWZ5IiwiREVGQVVMVF9ERUxJTUlURVIiLCJOT09QX1ZBTFVFIiwiSURfU1RBUlQiLCJJRF9DT05USU5VRSIsIkRFQlVHX1VSTCIsIlNJTVBMRV9UT0tFTlMiLCJlc2NhcGVUZXh0Iiwic3RyIiwicmVwbGFjZSIsImVzY2FwZSIsImxleGVyIiwiY2hhcnMiLCJpIiwibmFtZSIsInRlc3QiLCJwb3MiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJ0eXBlIiwiaW5kZXgiLCJJdGVyIiwiY29uc3RydWN0b3IiLCJ0b2tlbnMiLCJwZWVrIiwiX3BlZWsiLCJuZXh0IiwidHJ5Q29uc3VtZSIsInRva2VuIiwidW5kZWZpbmVkIiwiY29uc3VtZSIsIm5leHRUeXBlIiwidGV4dCIsInJlc3VsdCIsIm9wdGlvbnMiLCJlbmNvZGVQYXRoIiwiaXQiLCJlbmRUeXBlIiwicGF0aCIsInB1c2giLCJwYXJhbSIsIndpbGRjYXJkIiwib3BlbiIsImVuY29kZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImRlbGltaXRlciIsImRhdGEiLCJmbiIsInRva2Vuc1RvRnVuY3Rpb24iLCJtaXNzaW5nIiwiam9pbiIsImVuY29kZXJzIiwibWFwIiwidG9rZW5Ub0Z1bmN0aW9uIiwiZW5jb2RlciIsImV4dHJhcyIsImVuY29kZVZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVnZXhwIiwia2V5cyIsImRlY29kZXJzIiwia2V5Iiwic3BsaXQiLCJpbnB1dCIsIm0iLCJleGVjIiwicGFyYW1zIiwiY3JlYXRlIiwiZGVjb2RlciIsImVuZCIsInNlbnNpdGl2ZSIsInRyYWlsaW5nIiwic291cmNlcyIsImZsYWdzIiwicGF0aHMiLCJpdGVtcyIsInNlcSIsImZsYXR0ZW4iLCJzZXF1ZW5jZVRvUmVnRXhwIiwicGF0dGVybiIsIlJlZ0V4cCIsImluaXQiLCJmb3JrIiwic2xpY2UiLCJiYWNrdHJhY2siLCJpc1NhZmVTZWdtZW50UGFyYW0iLCJpbmNsdWRlcyIsIm5lZ2F0ZSIsInN0cmluZ2lmeVRva2VuIiwiaXNTYWZlIiwiaXNOYW1lU2FmZSIsImlzTmV4dE5hbWVTYWZlIiwiSlNPTiIsImZpcnN0IiwicmVzdCIsImV2ZXJ5IiwiY2hhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/path-to-regexp/dist/index.js\n");

/***/ })

};
;
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dotenv";
exports.ids = ["vendor-chunks/dotenv"];
exports.modules = {

/***/ "(rsc)/./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst packageJson = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/dotenv/package.json\");\nconst version = packageJson.version;\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n// Parse src into an Object\nfunction parse(src) {\n    const obj = {};\n    // Convert buffer to string\n    let lines = src.toString();\n    // Convert line breaks to same format\n    lines = lines.replace(/\\r\\n?/mg, \"\\n\");\n    let match;\n    while((match = LINE.exec(lines)) != null){\n        const key = match[1];\n        // Default undefined or null to empty string\n        let value = match[2] || \"\";\n        // Remove whitespace\n        value = value.trim();\n        // Check if double quoted\n        const maybeQuote = value[0];\n        // Remove surrounding quotes\n        value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, \"$2\");\n        // Expand newlines if double quoted\n        if (maybeQuote === '\"') {\n            value = value.replace(/\\\\n/g, \"\\n\");\n            value = value.replace(/\\\\r/g, \"\\r\");\n        }\n        // Add to object\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _parseVault(options) {\n    const vaultPath = _vaultPath(options);\n    // Parse .env.vault\n    const result = DotenvModule.configDotenv({\n        path: vaultPath\n    });\n    if (!result.parsed) {\n        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);\n        err.code = \"MISSING_DATA\";\n        throw err;\n    }\n    // handle scenario for comma separated keys - for use with key rotation\n    // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n    const keys = _dotenvKey(options).split(\",\");\n    const length = keys.length;\n    let decrypted;\n    for(let i = 0; i < length; i++){\n        try {\n            // Get full key\n            const key = keys[i].trim();\n            // Get instructions for decrypt\n            const attrs = _instructions(result, key);\n            // Decrypt\n            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);\n            break;\n        } catch (error) {\n            // last key\n            if (i + 1 >= length) {\n                throw error;\n            }\n        // try next key\n        }\n    }\n    // Parse decrypted .env string\n    return DotenvModule.parse(decrypted);\n}\nfunction _log(message) {\n    console.log(`[dotenv@${version}][INFO] ${message}`);\n}\nfunction _warn(message) {\n    console.log(`[dotenv@${version}][WARN] ${message}`);\n}\nfunction _debug(message) {\n    console.log(`[dotenv@${version}][DEBUG] ${message}`);\n}\nfunction _dotenvKey(options) {\n    // prioritize developer directly setting options.DOTENV_KEY\n    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n        return options.DOTENV_KEY;\n    }\n    // secondary infra already contains a DOTENV_KEY environment variable\n    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n        return process.env.DOTENV_KEY;\n    }\n    // fallback to empty string\n    return \"\";\n}\nfunction _instructions(result, dotenvKey) {\n    // Parse DOTENV_KEY. Format is a URI\n    let uri;\n    try {\n        uri = new URL(dotenvKey);\n    } catch (error) {\n        if (error.code === \"ERR_INVALID_URL\") {\n            const err = new Error(\"INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development\");\n            err.code = \"INVALID_DOTENV_KEY\";\n            throw err;\n        }\n        throw error;\n    }\n    // Get decrypt key\n    const key = uri.password;\n    if (!key) {\n        const err = new Error(\"INVALID_DOTENV_KEY: Missing key part\");\n        err.code = \"INVALID_DOTENV_KEY\";\n        throw err;\n    }\n    // Get environment\n    const environment = uri.searchParams.get(\"environment\");\n    if (!environment) {\n        const err = new Error(\"INVALID_DOTENV_KEY: Missing environment part\");\n        err.code = \"INVALID_DOTENV_KEY\";\n        throw err;\n    }\n    // Get ciphertext payload\n    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;\n    const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n    ;\n    if (!ciphertext) {\n        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);\n        err.code = \"NOT_FOUND_DOTENV_ENVIRONMENT\";\n        throw err;\n    }\n    return {\n        ciphertext,\n        key\n    };\n}\nfunction _vaultPath(options) {\n    let possibleVaultPath = null;\n    if (options && options.path && options.path.length > 0) {\n        if (Array.isArray(options.path)) {\n            for (const filepath of options.path){\n                if (fs.existsSync(filepath)) {\n                    possibleVaultPath = filepath.endsWith(\".vault\") ? filepath : `${filepath}.vault`;\n                }\n            }\n        } else {\n            possibleVaultPath = options.path.endsWith(\".vault\") ? options.path : `${options.path}.vault`;\n        }\n    } else {\n        possibleVaultPath = path.resolve(process.cwd(), \".env.vault\");\n    }\n    if (fs.existsSync(possibleVaultPath)) {\n        return possibleVaultPath;\n    }\n    return null;\n}\nfunction _resolveHome(envPath) {\n    return envPath[0] === \"~\" ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\nfunction _configVault(options) {\n    _log(\"Loading env from encrypted .env.vault\");\n    const parsed = DotenvModule._parseVault(options);\n    let processEnv = process.env;\n    if (options && options.processEnv != null) {\n        processEnv = options.processEnv;\n    }\n    DotenvModule.populate(processEnv, parsed, options);\n    return {\n        parsed\n    };\n}\nfunction configDotenv(options) {\n    const dotenvPath = path.resolve(process.cwd(), \".env\");\n    let encoding = \"utf8\";\n    const debug = Boolean(options && options.debug);\n    if (options && options.encoding) {\n        encoding = options.encoding;\n    } else {\n        if (debug) {\n            _debug(\"No encoding is specified. UTF-8 is used by default\");\n        }\n    }\n    let optionPaths = [\n        dotenvPath\n    ] // default, look for .env\n    ;\n    if (options && options.path) {\n        if (!Array.isArray(options.path)) {\n            optionPaths = [\n                _resolveHome(options.path)\n            ];\n        } else {\n            optionPaths = [] // reset default\n            ;\n            for (const filepath of options.path){\n                optionPaths.push(_resolveHome(filepath));\n            }\n        }\n    }\n    // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n    // parsed data, we will combine it with process.env (or options.processEnv if provided).\n    let lastError;\n    const parsedAll = {};\n    for (const path of optionPaths){\n        try {\n            // Specifying an encoding returns a string instead of a buffer\n            const parsed = DotenvModule.parse(fs.readFileSync(path, {\n                encoding\n            }));\n            DotenvModule.populate(parsedAll, parsed, options);\n        } catch (e) {\n            if (debug) {\n                _debug(`Failed to load ${path} ${e.message}`);\n            }\n            lastError = e;\n        }\n    }\n    let processEnv = process.env;\n    if (options && options.processEnv != null) {\n        processEnv = options.processEnv;\n    }\n    DotenvModule.populate(processEnv, parsedAll, options);\n    if (lastError) {\n        return {\n            parsed: parsedAll,\n            error: lastError\n        };\n    } else {\n        return {\n            parsed: parsedAll\n        };\n    }\n}\n// Populates process.env from .env file\nfunction config(options) {\n    // fallback to original dotenv if DOTENV_KEY is not set\n    if (_dotenvKey(options).length === 0) {\n        return DotenvModule.configDotenv(options);\n    }\n    const vaultPath = _vaultPath(options);\n    // dotenvKey exists but .env.vault file does not exist\n    if (!vaultPath) {\n        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);\n        return DotenvModule.configDotenv(options);\n    }\n    return DotenvModule._configVault(options);\n}\nfunction decrypt(encrypted, keyStr) {\n    const key = Buffer.from(keyStr.slice(-64), \"hex\");\n    let ciphertext = Buffer.from(encrypted, \"base64\");\n    const nonce = ciphertext.subarray(0, 12);\n    const authTag = ciphertext.subarray(-16);\n    ciphertext = ciphertext.subarray(12, -16);\n    try {\n        const aesgcm = crypto.createDecipheriv(\"aes-256-gcm\", key, nonce);\n        aesgcm.setAuthTag(authTag);\n        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;\n    } catch (error) {\n        const isRange = error instanceof RangeError;\n        const invalidKeyLength = error.message === \"Invalid key length\";\n        const decryptionFailed = error.message === \"Unsupported state or unable to authenticate data\";\n        if (isRange || invalidKeyLength) {\n            const err = new Error(\"INVALID_DOTENV_KEY: It must be 64 characters long (or more)\");\n            err.code = \"INVALID_DOTENV_KEY\";\n            throw err;\n        } else if (decryptionFailed) {\n            const err = new Error(\"DECRYPTION_FAILED: Please check your DOTENV_KEY\");\n            err.code = \"DECRYPTION_FAILED\";\n            throw err;\n        } else {\n            throw error;\n        }\n    }\n}\n// Populate process.env with parsed values\nfunction populate(processEnv, parsed, options = {}) {\n    const debug = Boolean(options && options.debug);\n    const override = Boolean(options && options.override);\n    if (typeof parsed !== \"object\") {\n        const err = new Error(\"OBJECT_REQUIRED: Please check the processEnv argument being passed to populate\");\n        err.code = \"OBJECT_REQUIRED\";\n        throw err;\n    }\n    // Set process.env\n    for (const key of Object.keys(parsed)){\n        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n            if (override === true) {\n                processEnv[key] = parsed[key];\n            }\n            if (debug) {\n                if (override === true) {\n                    _debug(`\"${key}\" is already defined and WAS overwritten`);\n                } else {\n                    _debug(`\"${key}\" is already defined and was NOT overwritten`);\n                }\n            }\n        } else {\n            processEnv[key] = parsed[key];\n        }\n    }\n}\nconst DotenvModule = {\n    configDotenv,\n    _configVault,\n    _parseVault,\n    config,\n    decrypt,\n    parse,\n    populate\n};\nmodule.exports.configDotenv = DotenvModule.configDotenv;\nmodule.exports._configVault = DotenvModule._configVault;\nmodule.exports._parseVault = DotenvModule._parseVault;\nmodule.exports.config = DotenvModule.config;\nmodule.exports.decrypt = DotenvModule.decrypt;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports.populate = DotenvModule.populate;\nmodule.exports = DotenvModule;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG90ZW52L2xpYi9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLEtBQUtGLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDO0FBRTVCLE1BQU1LLFVBQVVELFlBQVlDLE9BQU87QUFFbkMsTUFBTUMsT0FBTztBQUViLDJCQUEyQjtBQUMzQixTQUFTQyxNQUFPQyxHQUFHO0lBQ2pCLE1BQU1DLE1BQU0sQ0FBQztJQUViLDJCQUEyQjtJQUMzQixJQUFJQyxRQUFRRixJQUFJRyxRQUFRO0lBRXhCLHFDQUFxQztJQUNyQ0QsUUFBUUEsTUFBTUUsT0FBTyxDQUFDLFdBQVc7SUFFakMsSUFBSUM7SUFDSixNQUFPLENBQUNBLFFBQVFQLEtBQUtRLElBQUksQ0FBQ0osTUFBSyxLQUFNLEtBQU07UUFDekMsTUFBTUssTUFBTUYsS0FBSyxDQUFDLEVBQUU7UUFFcEIsNENBQTRDO1FBQzVDLElBQUlHLFFBQVNILEtBQUssQ0FBQyxFQUFFLElBQUk7UUFFekIsb0JBQW9CO1FBQ3BCRyxRQUFRQSxNQUFNQyxJQUFJO1FBRWxCLHlCQUF5QjtRQUN6QixNQUFNQyxhQUFhRixLQUFLLENBQUMsRUFBRTtRQUUzQiw0QkFBNEI7UUFDNUJBLFFBQVFBLE1BQU1KLE9BQU8sQ0FBQywwQkFBMEI7UUFFaEQsbUNBQW1DO1FBQ25DLElBQUlNLGVBQWUsS0FBSztZQUN0QkYsUUFBUUEsTUFBTUosT0FBTyxDQUFDLFFBQVE7WUFDOUJJLFFBQVFBLE1BQU1KLE9BQU8sQ0FBQyxRQUFRO1FBQ2hDO1FBRUEsZ0JBQWdCO1FBQ2hCSCxHQUFHLENBQUNNLElBQUksR0FBR0M7SUFDYjtJQUVBLE9BQU9QO0FBQ1Q7QUFFQSxTQUFTVSxZQUFhQyxPQUFPO0lBQzNCLE1BQU1D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c3Rib3QvLi9ub2RlX21vZHVsZXMvZG90ZW52L2xpYi9tYWluLmpzPzJkODQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG5jb25zdCBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG5cbmNvbnN0IHZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbmNvbnN0IExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZ1xuXG4vLyBQYXJzZSBzcmMgaW50byBhbiBPYmplY3RcbmZ1bmN0aW9uIHBhcnNlIChzcmMpIHtcbiAgY29uc3Qgb2JqID0ge31cblxuICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBzdHJpbmdcbiAgbGV0IGxpbmVzID0gc3JjLnRvU3RyaW5nKClcblxuICAvLyBDb252ZXJ0IGxpbmUgYnJlYWtzIHRvIHNhbWUgZm9ybWF0XG4gIGxpbmVzID0gbGluZXMucmVwbGFjZSgvXFxyXFxuPy9tZywgJ1xcbicpXG5cbiAgbGV0IG1hdGNoXG4gIHdoaWxlICgobWF0Y2ggPSBMSU5FLmV4ZWMobGluZXMpKSAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5ID0gbWF0Y2hbMV1cblxuICAgIC8vIERlZmF1bHQgdW5kZWZpbmVkIG9yIG51bGwgdG8gZW1wdHkgc3RyaW5nXG4gICAgbGV0IHZhbHVlID0gKG1hdGNoWzJdIHx8ICcnKVxuXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgLy8gQ2hlY2sgaWYgZG91YmxlIHF1b3RlZFxuICAgIGNvbnN0IG1heWJlUXVvdGUgPSB2YWx1ZVswXVxuXG4gICAgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3Rlc1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihbJ1wiYF0pKFtcXHNcXFNdKilcXDEkL21nLCAnJDInKVxuXG4gICAgLy8gRXhwYW5kIG5ld2xpbmVzIGlmIGRvdWJsZSBxdW90ZWRcbiAgICBpZiAobWF5YmVRdW90ZSA9PT0gJ1wiJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpXG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIG9iamVjdFxuICAgIG9ialtrZXldID0gdmFsdWVcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gX3BhcnNlVmF1bHQgKG9wdGlvbnMpIHtcbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIFBhcnNlIC5lbnYudmF1bHRcbiAgY29uc3QgcmVzdWx0ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudih7IHBhdGg6IHZhdWx0UGF0aCB9KVxuICBpZiAoIXJlc3VsdC5wYXJzZWQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE1JU1NJTkdfREFUQTogQ2Fubm90IHBhcnNlICR7dmF1bHRQYXRofSBmb3IgYW4gdW5rbm93biByZWFzb25gKVxuICAgIGVyci5jb2RlID0gJ01JU1NJTkdfREFUQSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIGhhbmRsZSBzY2VuYXJpbyBmb3IgY29tbWEgc2VwYXJhdGVkIGtleXMgLSBmb3IgdXNlIHdpdGgga2V5IHJvdGF0aW9uXG4gIC8vIGV4YW1wbGU6IERPVEVOVl9LRVk9XCJkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kLGRvdGVudjovLzprZXlfNzg5MEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PXByb2RcIlxuICBjb25zdCBrZXlzID0gX2RvdGVudktleShvcHRpb25zKS5zcGxpdCgnLCcpXG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cbiAgbGV0IGRlY3J5cHRlZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBmdWxsIGtleVxuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXS50cmltKClcblxuICAgICAgLy8gR2V0IGluc3RydWN0aW9ucyBmb3IgZGVjcnlwdFxuICAgICAgY29uc3QgYXR0cnMgPSBfaW5zdHJ1Y3Rpb25zKHJlc3VsdCwga2V5KVxuXG4gICAgICAvLyBEZWNyeXB0XG4gICAgICBkZWNyeXB0ZWQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdChhdHRycy5jaXBoZXJ0ZXh0LCBhdHRycy5rZXkpXG5cbiAgICAgIGJyZWFrXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGxhc3Qga2V5XG4gICAgICBpZiAoaSArIDEgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICAvLyB0cnkgbmV4dCBrZXlcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBkZWNyeXB0ZWQgLmVudiBzdHJpbmdcbiAgcmV0dXJuIERvdGVudk1vZHVsZS5wYXJzZShkZWNyeXB0ZWQpXG59XG5cbmZ1bmN0aW9uIF9sb2cgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bSU5GT10gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF93YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW1dBUk5dICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZGVidWcgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bREVCVUddICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZG90ZW52S2V5IChvcHRpb25zKSB7XG4gIC8vIHByaW9yaXRpemUgZGV2ZWxvcGVyIGRpcmVjdGx5IHNldHRpbmcgb3B0aW9ucy5ET1RFTlZfS0VZXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuRE9URU5WX0tFWSAmJiBvcHRpb25zLkRPVEVOVl9LRVkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBvcHRpb25zLkRPVEVOVl9LRVlcbiAgfVxuXG4gIC8vIHNlY29uZGFyeSBpbmZyYSBhbHJlYWR5IGNvbnRhaW5zIGEgRE9URU5WX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICBpZiAocHJvY2Vzcy5lbnYuRE9URU5WX0tFWSAmJiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuRE9URU5WX0tFWVxuICB9XG5cbiAgLy8gZmFsbGJhY2sgdG8gZW1wdHkgc3RyaW5nXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBfaW5zdHJ1Y3Rpb25zIChyZXN1bHQsIGRvdGVudktleSkge1xuICAvLyBQYXJzZSBET1RFTlZfS0VZLiBGb3JtYXQgaXMgYSBVUklcbiAgbGV0IHVyaVxuICB0cnkge1xuICAgIHVyaSA9IG5ldyBVUkwoZG90ZW52S2V5KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5jb2RlID09PSAnRVJSX0lOVkFMSURfVVJMJykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IFdyb25nIGZvcm1hdC4gTXVzdCBiZSBpbiB2YWxpZCB1cmkgZm9ybWF0IGxpa2UgZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9ZGV2ZWxvcG1lbnQnKVxuICAgICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIC8vIEdldCBkZWNyeXB0IGtleVxuICBjb25zdCBrZXkgPSB1cmkucGFzc3dvcmRcbiAgaWYgKCFrZXkpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBrZXkgcGFydCcpXG4gICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gR2V0IGVudmlyb25tZW50XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXJpLnNlYXJjaFBhcmFtcy5nZXQoJ2Vudmlyb25tZW50JylcbiAgaWYgKCFlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGVudmlyb25tZW50IHBhcnQnKVxuICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIEdldCBjaXBoZXJ0ZXh0IHBheWxvYWRcbiAgY29uc3QgZW52aXJvbm1lbnRLZXkgPSBgRE9URU5WX1ZBVUxUXyR7ZW52aXJvbm1lbnQudG9VcHBlckNhc2UoKX1gXG4gIGNvbnN0IGNpcGhlcnRleHQgPSByZXN1bHQucGFyc2VkW2Vudmlyb25tZW50S2V5XSAvLyBET1RFTlZfVkFVTFRfUFJPRFVDVElPTlxuICBpZiAoIWNpcGhlcnRleHQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE5PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlQ6IENhbm5vdCBsb2NhdGUgZW52aXJvbm1lbnQgJHtlbnZpcm9ubWVudEtleX0gaW4geW91ciAuZW52LnZhdWx0IGZpbGUuYClcbiAgICBlcnIuY29kZSA9ICdOT1RfRk9VTkRfRE9URU5WX0VOVklST05NRU5UJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgcmV0dXJuIHsgY2lwaGVydGV4dCwga2V5IH1cbn1cblxuZnVuY3Rpb24gX3ZhdWx0UGF0aCAob3B0aW9ucykge1xuICBsZXQgcG9zc2libGVWYXVsdFBhdGggPSBudWxsXG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkge1xuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XG4gICAgICAgICAgcG9zc2libGVWYXVsdFBhdGggPSBmaWxlcGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBmaWxlcGF0aCA6IGAke2ZpbGVwYXRofS52YXVsdGBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBvcHRpb25zLnBhdGggOiBgJHtvcHRpb25zLnBhdGh9LnZhdWx0YFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudi52YXVsdCcpXG4gIH1cblxuICBpZiAoZnMuZXhpc3RzU3luYyhwb3NzaWJsZVZhdWx0UGF0aCkpIHtcbiAgICByZXR1cm4gcG9zc2libGVWYXVsdFBhdGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlSG9tZSAoZW52UGF0aCkge1xuICByZXR1cm4gZW52UGF0aFswXSA9PT0gJ34nID8gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgZW52UGF0aC5zbGljZSgxKSkgOiBlbnZQYXRoXG59XG5cbmZ1bmN0aW9uIF9jb25maWdWYXVsdCAob3B0aW9ucykge1xuICBfbG9nKCdMb2FkaW5nIGVudiBmcm9tIGVuY3J5cHRlZCAuZW52LnZhdWx0JylcblxuICBjb25zdCBwYXJzZWQgPSBEb3RlbnZNb2R1bGUuX3BhcnNlVmF1bHQob3B0aW9ucylcblxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHByb2Nlc3NFbnYsIHBhcnNlZCwgb3B0aW9ucylcblxuICByZXR1cm4geyBwYXJzZWQgfVxufVxuXG5mdW5jdGlvbiBjb25maWdEb3RlbnYgKG9wdGlvbnMpIHtcbiAgY29uc3QgZG90ZW52UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudicpXG4gIGxldCBlbmNvZGluZyA9ICd1dGY4J1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIF9kZWJ1ZygnTm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkLiBVVEYtOCBpcyB1c2VkIGJ5IGRlZmF1bHQnKVxuICAgIH1cbiAgfVxuXG4gIGxldCBvcHRpb25QYXRocyA9IFtkb3RlbnZQYXRoXSAvLyBkZWZhdWx0LCBsb29rIGZvciAuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBvcHRpb25QYXRocyA9IFtfcmVzb2x2ZUhvbWUob3B0aW9ucy5wYXRoKV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbXSAvLyByZXNldCBkZWZhdWx0XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIG9wdGlvbnMucGF0aCkge1xuICAgICAgICBvcHRpb25QYXRocy5wdXNoKF9yZXNvbHZlSG9tZShmaWxlcGF0aCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHBhcnNlZCBkYXRhIGluIGEgdGVtcG9yYXJ5IG9iamVjdCAoYmVjYXVzZSB3ZSBuZWVkIHRvIHJldHVybiBpdCkuICBPbmNlIHdlIGhhdmUgdGhlIGZpbmFsXG4gIC8vIHBhcnNlZCBkYXRhLCB3ZSB3aWxsIGNvbWJpbmUgaXQgd2l0aCBwcm9jZXNzLmVudiAob3Igb3B0aW9ucy5wcm9jZXNzRW52IGlmIHByb3ZpZGVkKS5cbiAgbGV0IGxhc3RFcnJvclxuICBjb25zdCBwYXJzZWRBbGwgPSB7fVxuICBmb3IgKGNvbnN0IHBhdGggb2Ygb3B0aW9uUGF0aHMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3BlY2lmeWluZyBhbiBlbmNvZGluZyByZXR1cm5zIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBidWZmZXJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZyB9KSlcblxuICAgICAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHBhcnNlZEFsbCwgcGFyc2VkLCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBfZGVidWcoYEZhaWxlZCB0byBsb2FkICR7cGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICAgIGxhc3RFcnJvciA9IGVcbiAgICB9XG4gIH1cblxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHByb2Nlc3NFbnYsIHBhcnNlZEFsbCwgb3B0aW9ucylcblxuICBpZiAobGFzdEVycm9yKSB7XG4gICAgcmV0dXJuIHsgcGFyc2VkOiBwYXJzZWRBbGwsIGVycm9yOiBsYXN0RXJyb3IgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsIH1cbiAgfVxufVxuXG4vLyBQb3B1bGF0ZXMgcHJvY2Vzcy5lbnYgZnJvbSAuZW52IGZpbGVcbmZ1bmN0aW9uIGNvbmZpZyAob3B0aW9ucykge1xuICAvLyBmYWxsYmFjayB0byBvcmlnaW5hbCBkb3RlbnYgaWYgRE9URU5WX0tFWSBpcyBub3Qgc2V0XG4gIGlmIChfZG90ZW52S2V5KG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCB2YXVsdFBhdGggPSBfdmF1bHRQYXRoKG9wdGlvbnMpXG5cbiAgLy8gZG90ZW52S2V5IGV4aXN0cyBidXQgLmVudi52YXVsdCBmaWxlIGRvZXMgbm90IGV4aXN0XG4gIGlmICghdmF1bHRQYXRoKSB7XG4gICAgX3dhcm4oYFlvdSBzZXQgRE9URU5WX0tFWSBidXQgeW91IGFyZSBtaXNzaW5nIGEgLmVudi52YXVsdCBmaWxlIGF0ICR7dmF1bHRQYXRofS4gRGlkIHlvdSBmb3JnZXQgdG8gYnVpbGQgaXQ/YClcblxuICAgIHJldHVybiBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gRG90ZW52TW9kdWxlLl9jb25maWdWYXVsdChvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBkZWNyeXB0IChlbmNyeXB0ZWQsIGtleVN0cikge1xuICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShrZXlTdHIuc2xpY2UoLTY0KSwgJ2hleCcpXG4gIGxldCBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkLCAnYmFzZTY0JylcblxuICBjb25zdCBub25jZSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgMTIpXG4gIGNvbnN0IGF1dGhUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC0xNilcbiAgY2lwaGVydGV4dCA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMTIsIC0xNilcblxuICB0cnkge1xuICAgIGNvbnN0IGFlc2djbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMjU2LWdjbScsIGtleSwgbm9uY2UpXG4gICAgYWVzZ2NtLnNldEF1dGhUYWcoYXV0aFRhZylcbiAgICByZXR1cm4gYCR7YWVzZ2NtLnVwZGF0ZShjaXBoZXJ0ZXh0KX0ke2Flc2djbS5maW5hbCgpfWBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpc1JhbmdlID0gZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yXG4gICAgY29uc3QgaW52YWxpZEtleUxlbmd0aCA9IGVycm9yLm1lc3NhZ2UgPT09ICdJbnZhbGlkIGtleSBsZW5ndGgnXG4gICAgY29uc3QgZGVjcnlwdGlvbkZhaWxlZCA9IGVycm9yLm1lc3NhZ2UgPT09ICdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnXG5cbiAgICBpZiAoaXNSYW5nZSB8fCBpbnZhbGlkS2V5TGVuZ3RoKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogSXQgbXVzdCBiZSA2NCBjaGFyYWN0ZXJzIGxvbmcgKG9yIG1vcmUpJylcbiAgICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSBpZiAoZGVjcnlwdGlvbkZhaWxlZCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdERUNSWVBUSU9OX0ZBSUxFRDogUGxlYXNlIGNoZWNrIHlvdXIgRE9URU5WX0tFWScpXG4gICAgICBlcnIuY29kZSA9ICdERUNSWVBUSU9OX0ZBSUxFRCdcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuXG4vLyBQb3B1bGF0ZSBwcm9jZXNzLmVudiB3aXRoIHBhcnNlZCB2YWx1ZXNcbmZ1bmN0aW9uIHBvcHVsYXRlIChwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuICBjb25zdCBvdmVycmlkZSA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJyaWRlKVxuXG4gIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignT0JKRUNUX1JFUVVJUkVEOiBQbGVhc2UgY2hlY2sgdGhlIHByb2Nlc3NFbnYgYXJndW1lbnQgYmVpbmcgcGFzc2VkIHRvIHBvcHVsYXRlJylcbiAgICBlcnIuY29kZSA9ICdPQkpFQ1RfUkVRVUlSRUQnXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBTZXQgcHJvY2Vzcy5lbnZcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyc2VkKSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzc0Vudiwga2V5KSkge1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgIHByb2Nlc3NFbnZba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgICB9XG5cbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCBXQVMgb3ZlcndyaXR0ZW5gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9kZWJ1ZyhgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIHdhcyBOT1Qgb3ZlcndyaXR0ZW5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NFbnZba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IERvdGVudk1vZHVsZSA9IHtcbiAgY29uZmlnRG90ZW52LFxuICBfY29uZmlnVmF1bHQsXG4gIF9wYXJzZVZhdWx0LFxuICBjb25maWcsXG4gIGRlY3J5cHQsXG4gIHBhcnNlLFxuICBwb3B1bGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25maWdEb3RlbnYgPSBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52XG5tb2R1bGUuZXhwb3J0cy5fY29uZmlnVmF1bHQgPSBEb3RlbnZNb2R1bGUuX2NvbmZpZ1ZhdWx0XG5tb2R1bGUuZXhwb3J0cy5fcGFyc2VWYXVsdCA9IERvdGVudk1vZHVsZS5fcGFyc2VWYXVsdFxubW9kdWxlLmV4cG9ydHMuY29uZmlnID0gRG90ZW52TW9kdWxlLmNvbmZpZ1xubW9kdWxlLmV4cG9ydHMuZGVjcnlwdCA9IERvdGVudk1vZHVsZS5kZWNyeXB0XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IERvdGVudk1vZHVsZS5wYXJzZVxubW9kdWxlLmV4cG9ydHMucG9wdWxhdGUgPSBEb3RlbnZNb2R1bGUucG9wdWxhdGVcblxubW9kdWxlLmV4cG9ydHMgPSBEb3RlbnZNb2R1bGVcbiJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwib3MiLCJjcnlwdG8iLCJwYWNrYWdlSnNvbiIsInZlcnNpb24iLCJMSU5FIiwicGFyc2UiLCJzcmMiLCJvYmoiLCJsaW5lcyIsInRvU3RyaW5nIiwicmVwbGFjZSIsIm1hdGNoIiwiZXhlYyIsImtleSIsInZhbHVlIiwidHJpbSIsIm1heWJlUXVvdGUiLCJfcGFyc2VWYXVsdCIsIm9wdGlvbnMiLCJ2YXVsdFBhdGgiLCJfdmF1bHRQYXRoIiwicmVzdWx0IiwiRG90ZW52TW9kdWxlIiwiY29uZmlnRG90ZW52IiwicGFyc2VkIiwiZXJyIiwiRXJyb3IiLCJjb2RlIiwia2V5cyIsIl9kb3RlbnZLZXkiLCJzcGxpdCIsImxlbmd0aCIsImRlY3J5cHRlZCIsImkiLCJhdHRycyIsIl9pbnN0cnVjdGlvbnMiLCJkZWNyeXB0IiwiY2lwaGVydGV4dCIsImVycm9yIiwiX2xvZyIsIm1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIiwiX3dhcm4iLCJfZGVidWciLCJET1RFTlZfS0VZIiwicHJvY2VzcyIsImVudiIsImRvdGVudktleSIsInVyaSIsIlVSTCIsInBhc3N3b3JkIiwiZW52aXJvbm1lbnQiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJlbnZpcm9ubWVudEtleSIsInRvVXBwZXJDYXNlIiwicG9zc2libGVWYXVsdFBhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJmaWxlcGF0aCIsImV4aXN0c1N5bmMiLCJlbmRzV2l0aCIsInJlc29sdmUiLCJjd2QiLCJfcmVzb2x2ZUhvbWUiLCJlbnZQYXRoIiwiam9pbiIsImhvbWVkaXIiLCJzbGljZSIsIl9jb25maWdWYXVsdCIsInByb2Nlc3NFbnYiLCJwb3B1bGF0ZSIsImRvdGVudlBhdGgiLCJlbmNvZGluZyIsImRlYnVnIiwiQm9vbGVhbiIsIm9wdGlvblBhdGhzIiwicHVzaCIsImxhc3RFcnJvciIsInBhcnNlZEFsbCIsInJlYWRGaWxlU3luYyIsImUiLCJjb25maWciLCJlbmNyeXB0ZWQiLCJrZXlTdHIiLCJCdWZmZXIiLCJmcm9tIiwibm9uY2UiLCJzdWJhcnJheSIsImF1dGhUYWciLCJhZXNnY20iLCJjcmVhdGVEZWNpcGhlcml2Iiwic2V0QXV0aFRhZyIsInVwZGF0ZSIsImZpbmFsIiwiaXNSYW5nZSIsIlJhbmdlRXJyb3IiLCJpbnZhbGlkS2V5TGVuZ3RoIiwiZGVjcnlwdGlvbkZhaWxlZCIsIm92ZXJyaWRlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dotenv/lib/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dotenv/package.json":
/*!******************************************!*\
  !*** ./node_modules/dotenv/package.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"dotenv","version":"16.4.7","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ })

};
;